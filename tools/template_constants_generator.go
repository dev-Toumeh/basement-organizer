package main

import (
	"basement/main/internal/env"
	"basement/main/internal/logg"
	"basement/main/internal/templates"
	"fmt"
	"go/format"
	"html/template"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

const (
	TEMPLATES_DIR            string = "../internal"
	TEMPLATES_CONSTANTS_PATH string = "../internal/templates/constants.go"
	TARGET_TEMPLATES_DIR     string = templates.TEMPLATE_DIR
)

// GenerateTemplateNames automatically generates cons variables from parsed template definitions.//
// File definitions are parsed from "TEMPLATES_DIR".
//
// Creates "constants.go" file defined in "TEMPLATES_CONSTRANTS_PATH".
func main() {
	env.Config().SetDebugLogsEnabled(true)
	env.Config().SetInfoLogsEnabled(true)
	template, paths, err := templates.ParseDirectory(TEMPLATES_DIR)
	if err != nil {
		panic(err)
	}
	err = GenerateTemplateNames(template, paths)
	if err != nil {
		panic(err)
	}
}

// GenerateTemplateNames automatically generates cons variables from parsed template definitions.//
// File definitions are parsed from "TEMPLATES_DIR".
//
// Creates "constants.go" file defined in "TEMPLATES_CONSTRANTS_PATH".
func GenerateTemplateNames(template *template.Template, parsedPaths []string) error {
	definedTemplates := template.DefinedTemplates()
	templatesList := strings.Split(strings.TrimPrefix(definedTemplates, "; defined templates are: "), ", ")

	// No redundant ".html" template definitions
	var filteredTemplates []string
	for _, t := range templatesList {
		if !strings.Contains(t, ".html") {
			filteredTemplates = append(filteredTemplates, strings.TrimSpace(t))
		}
	}
	if len(filteredTemplates) == 0 {
		panic("no valid templates found")
	}

	// Map parsed paths for easy lookup
	parsedPathsMap := make(map[string]string, len(parsedPaths))
	for _, path := range parsedPaths {
		parsedPathsMap[filepath.Base(path)] = filepath.ToSlash(path)
	}

	constVariables := make([]string, len(filteredTemplates))
	for i, tmpl := range filteredTemplates {
		cleanName := strings.Trim(tmpl, `"`)
		fileSource := template.Lookup(cleanName).Tree.ParseName
		mappedPath, ok := parsedPathsMap[filepath.Base(fileSource)]
		if !ok {
			panic("path not found for template: " + tmpl)
		}

		// Format template name like:
		// TEMPLATE_MY_TEMPLATE string = "my-template" // internal/templates/my-template.html
		constName := "TEMPLATE_" + strings.ToUpper(strings.ReplaceAll(strings.ReplaceAll(cleanName, "-", "_"), ".", "_"))
		constValue := tmpl
		constValuePathComment := strings.TrimPrefix(mappedPath, "../")
		constVariables[i] = fmt.Sprintf("%s string = %s // %s", constName, constValue, constValuePathComment)
	}

	sort.Strings(constVariables)

	fileContent := `// THIS FILE IS AUTO GENERATED BY 'template_constants_generator.go'!
// DO NOT EDIT, CHANGES WILL BE LOST!
// TEMPLATE_<name> is the definition name of that template
// TEMPLATE_<name>_PATH is the file where this definition is

package templates

const(` + strings.Join(constVariables, "\n") + "\n)"

	formattedContent, err := format.Source([]byte(fileContent))
	if err != nil {
		panic("error formatting content: " + err.Error())
	}
	logg.Debug(string(formattedContent))

	file, err := os.OpenFile(TEMPLATES_CONSTANTS_PATH, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666)
	// file, err := os.OpenFile(TEMPLATES_CONSTANTS_PATH, os.O_RDWR|os.O_CREATE, 0666)
	if err != nil {
		return fmt.Errorf("failed to open file: %w", err)
	}
	defer file.Close()

	if _, err := file.Write(formattedContent); err != nil {
		panic("failed to write content: " + err.Error())
	}

	logg.Infof("Generated template constants at '%s'", TEMPLATES_CONSTANTS_PATH)
	return nil
}
